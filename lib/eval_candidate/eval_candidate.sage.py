

# This file was *autogenerated* from the file eval_candidate.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_0p1 = RealNumber('0.1'); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p100 = RealNumber('0.100'); _sage_const_0p8 = RealNumber('0.8'); _sage_const_24 = Integer(24); _sage_const_25 = Integer(25)
from multiprocessing import Process, Pipe 
import time
def LBound(x,a=_sage_const_1 /_sage_const_2 ,c=_sage_const_1 ): return exp(c*( (ln(x)**a) * (ln(ln(x))**(_sage_const_1 -a)) ))

def is_L_smooth(factors, L):
	is_smooth=True
	for i in factors:
		if i>_sage_const_5 *L:
			is_smooth=False
			break
	return is_smooth


def fac(cpr,fps):
	while True:
		#print("Waiting")
		c=cpr.recv()
		c=abs(c)
		L=floor(float(LBound(c)))
		#print("Factoring")

		if c%_sage_const_4 ==_sage_const_1 :
			factors=ecm.factor(c-_sage_const_1 ,None)
		else:
			factors=ecm.factor(c+_sage_const_1 ,None)

		fps.send((factors, c, L))


def eval_candidates_for_nprimes(nprimes):
	name="../ideals/candidate_conductors"+str(nprimes)+".md"
	F=open(name, "r", encoding="utf-8")

	nprimes=Integer(F.readline())
	nb_factored=_sage_const_0 
	nb_candidates=_sage_const_10 

	candidates=[]
	fs=[_sage_const_2 ]*(_sage_const_2 *nb_candidates)

	f_re_str=''
	f_im_str=''

	processes=[None]*(_sage_const_2 *nb_candidates)

	pipes_cand=[]
	pipes_fac=[]

	#cqr, cqs

	for i in range(_sage_const_2 *nb_candidates):
		pipes_cand.append(Pipe(duplex=False))
		pipes_fac.append(Pipe(duplex=False))
		processes[i]=Process(target=fac, args=(pipes_cand[i][_sage_const_0 ],pipes_fac[i][_sage_const_1 ]))
		processes[i].start()


	eof=False
	while not eof:
		nb_factored+=_sage_const_1 
		#Multiple loops for readability, doesn't impact perf here

		for i in range(nb_candidates):
		#Read nb_processes candidates
			f_re_str=F.readline()
			f_im_str=F.readline()
			if f_re_str == '' or f_im_str=='':
				eof=True
				break
			f_re_str=f_re_str.split(' ')
			f_im_str=f_im_str.split(' ')
			
			fs[i]=(Integer(f_re_str[_sage_const_0 ]),Integer(f_re_str[_sage_const_1 ][_sage_const_0 ]))
			fs[i+_sage_const_1 ]=(Integer(f_im_str[_sage_const_0 ]),Integer(f_im_str[_sage_const_1 ][_sage_const_0 ]))
			print("Attempting to factor:",fs[i], fs[i+_sage_const_1 ])
		if eof:
			break

		time.sleep(float(_sage_const_0p1 ))
		for i in range(nb_candidates):
		#send each candidate to a process
			if fs[i][_sage_const_1 ]==_sage_const_0 :
				continue
			pipes_cand[i][_sage_const_1 ].send(fs[i][_sage_const_0 ])

		time.sleep(float(_sage_const_0p5 ))
		for i in range(nb_candidates):
		#Check only if candidate was prime
			if fs[i][_sage_const_1 ]==_sage_const_0 :
				continue
			#timeout at 0.3 secs
			if pipes_fac[i][_sage_const_0 ].poll():
				#check if process nb i terminated
				factors=pipes_fac[i][_sage_const_0 ].recv()
			else:
				#terminate the process and launch another one
				processes[i].terminate()
				print(f"Candidate {fs[i]} timed out\n")

				pipes_cand[i]=Pipe(duplex=False)
				pipes_fac[i]=Pipe(duplex=False)
				processes[i]=Process(target=fac, args=(pipes_cand[i][_sage_const_0 ],pipes_fac[i][_sage_const_1 ]))
				processes[i].start()

				continue

			#check if candidate has L-smooth class number
			if is_L_smooth(factors[_sage_const_0 ], factors[_sage_const_2 ]):
				print(f"Conductor {factors[_sage_const_1 ]} gives: {factors[_sage_const_0 ]}")
				candidates.append(factors)
				#if len(candidates)==3:
					#eof=True
					#break
			else:
				print(f"Candidate {factors[_sage_const_1 ]} doesnt give {factors[_sage_const_2 ]}-smooth class group:\n\t{factors[_sage_const_0 ]}")

	time.sleep(float(_sage_const_0p100 ))
	for i in range(len(fs)):
	#send each candidate to a process
		if type(fs[i])==Integer or fs[i][_sage_const_1 ]==_sage_const_0 :
			continue
		pipes_cand[i][_sage_const_1 ].send(fs[i][_sage_const_0 ])

	time.sleep(float(_sage_const_0p8 ))
	for i in range(len(fs)):
		#timeout at 0.3 secs
		if type(fs[i])==Integer or fs[i][_sage_const_1 ]==_sage_const_0 :
			continue
		if pipes_fac[i][_sage_const_0 ].poll():
			#check if process nb i terminated
			factors=pipes_fac[i][_sage_const_0 ].recv()
		else:
			#terminate the process and launch another one
			processes[i].terminate()
			print(f"Candidate {fs[i]} timed out\n")

			pipes_cand[i]=Pipe(duplex=False)
			pipes_fac[i]=Pipe(duplex=False)
			processes[i]=Process(target=fac, args=(pipes_cand[i][_sage_const_0 ],pipes_fac[i][_sage_const_1 ]))
			processes[i].start()
			continue

		#check if candidate has L-smooth class number
		if is_L_smooth(factors[_sage_const_0 ], factors[_sage_const_2 ]):
			print(f"Conductor {factors[_sage_const_1 ]} gives: {factors[_sage_const_0 ]}")
			candidates.append(factors)
			#if len(candidates)==3:
				#eof=True
				#break
		else:
			print(f"Candidate {factors[_sage_const_1 ]} doesnt give {factors[_sage_const_2 ]}-smooth class group:\n\t{factors[_sage_const_0 ]}")


	for p in processes:
		p.terminate()
	F.close()
	print("Number of factored candidates", nb_factored*nb_candidates)
	print(candidates)

	out_file_name="conductors_data"+str(nprimes)+".md"
	G=open(out_file_name, "w", encoding="utf-8")
	G.write(f'Number of primes used: {nprimes}\n')
	for candidate in candidates:
		G.write(f"{candidate[_sage_const_1 ]} is O({candidate[_sage_const_2 ]})-smooth:\n\t {candidate[_sage_const_0 ]}\n")
	
	G.close()

nprimes=_sage_const_24 

while nprimes < _sage_const_25 :
	eval_candidates_for_nprimes(nprimes)
	nprimes+=_sage_const_1 




# This file was *autogenerated* from the file attach_sequence_to_candidate.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_1000000 = Integer(1000000); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_3 = Integer(3); _sage_const_100000 = Integer(100000)
from argparse import ArgumentParser

parser=ArgumentParser()
parser.add_argument('-in','--initial_nb_primes', default='2')
parser.add_argument('-mn','--maximal_nb_primes', default='3')
parser.add_argument('-v','--verbose', action='store_true')

args=parser.parse_args()

def next(L, p_above,p_above_conj, nb_primes, prev_seq, next_seq):
	for i in range(nb_primes-_sage_const_1 ):
		j=prev_seq[i]
		k=next_seq[i]
		if j!=k:
			L=L*(p_above[i+_sage_const_1 ]**(_sage_const_2 *k))
			L=L*(p_above_conj[i+_sage_const_1 ]**(_sage_const_2 *(-k)))
	return L

def gen_candidates(K, p_above, p_above_conj, f_abs, a_abs, stop=_sage_const_1000000 , G_index=_sage_const_0 ):
	nb_primes=len(p_above)
	print(nb_primes)

	L_2=p_above[_sage_const_0 ]
	L_1=prod(p_above_conj[_sage_const_1 :len(p_above)])**(_sage_const_2 )
	L=L_1*L_2

	#could try not generating it each time
	G=cartesian_product([[-_sage_const_1 ,_sage_const_1 ] for i in range(nb_primes-_sage_const_1 )])


	prev_seq=G[_sage_const_0 ]
	i=_sage_const_0 
	for next_seq in G:
		if i<G_index:
			i+=_sage_const_1 
			continue
		if stop==_sage_const_0 :
			break

		L=next(L,p_above, p_above_conj,nb_primes,prev_seq,next_seq)
		prev_seq=next_seq

		f_im=Integer(L.gens_reduced()[_sage_const_0 ].imag())
		f_re=Integer(L.gens_reduced()[_sage_const_0 ].real())

		if args.verbose:
			print(f"Real part of w: {f_re}")
			print(f"Imaginary part of w: {f_im}")

		if args.verbose:
			print(f"Corresponding sequence: {[_sage_const_1 ]+list(prev_seq)}")

		if abs(f_re) in [f_abs, a_abs] and abs(f_re) in [f_abs, a_abs]:
			which=_sage_const_0 
			if abs(f_re)==a_abs:
				which=_sage_const_1 
			return (f_re, f_im, [_sage_const_1 ]+list(prev_seq), which)
		i+=_sage_const_1 


def add_prime_above(p_above, p_above_conj, p):
	primes_above=K.primes_above(p)
	p_above.append(primes_above[_sage_const_0 ])
	p_above_conj.append(primes_above[_sage_const_1 ])
	return (p_above, p_above_conj)


initial_nb_primes=Integer(args.initial_nb_primes)
max_nb_primes=Integer(args.maximal_nb_primes)

K = NumberField(x**_sage_const_2 +_sage_const_1 , names=('i',)); (i,) = K._first_ngens(1)
p=_sage_const_5 
split_primes=[]
p_above=[]
p_above_conj=[]
i=_sage_const_0 

while i<initial_nb_primes:
	if p&_sage_const_3 ==_sage_const_1 :
		split_primes.append(p)
		(p_above, p_above_conj)=add_prime_above(p_above, p_above_conj, p)
		i+=_sage_const_1 
	p=p.next_prime()

nb_primes=max_nb_primes

while nb_primes<=max_nb_primes:
	while p&_sage_const_3 !=_sage_const_1 :
		p=p.next_prime()

	split_primes.append(p)
	(p_above, p_above_conj)=add_prime_above(p_above, p_above_conj, p)

	if args.verbose:
		print(f"Searching w for primes {split_primes}")

	name1="../../txt/alpha_"+str(nb_primes)+"_primes.md"
	name2="../../txt/w_"+str(nb_primes)+"_primes.md"
	if args.verbose:
		print(f"Reading alpha in {name1}")

	F=open(name1, 'r', encoding="utf-8")
	f_abs=Integer(F.readline())
	a_abs=Integer(F.readline())
	F.close()
	if args.verbose:
		print(f"alpha={a_abs}+i{f_abs}")

	res=gen_candidates(K, p_above, p_above_conj, f_abs, a_abs, stop=_sage_const_100000 )
	if args.verbose:
		print(f"Found corresponding w {res[_sage_const_0 ]}+i{res[_sage_const_1 ]}\n corresponding to sequence\n\t{res[_sage_const_2 ]}\n")

	if args.verbose:
		print(f"Writing w in {name2}")

	G=open(name2, 'w', encoding="utf-8")
	G.write(str(res[res[_sage_const_3 ]]))
	G.write('\n')
	G.write(str(res[abs(res[_sage_const_3 ]-_sage_const_1 )]))
	G.write('\n')
	seq=res[_sage_const_2 ]
	for pmone in seq:
		G.write(str(pmone))
		G.write('\n')
	G.close()


	p=p.next_prime()
	nb_primes+=_sage_const_1 




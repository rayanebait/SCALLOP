

# This file was *autogenerated* from the file babai.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_15 = Integer(15); _sage_const_3 = Integer(3); _sage_const_300 = Integer(300); _sage_const_0 = Integer(0)#A a pour colonnes la base, A_ est la base réduite
#t est le vecteur dont on cherche le vecteur proche

def babai(A,A_, t):
	s=-t

	I=A.columns()
	I.reverse()

	J=A_.columns()
	J.reverse()

	vecs=zip(I,J)
	c=_sage_const_1 
	for (v,v_) in vecs:
		c=floor((s*v_)/(v_*v_))
		s=s-c*v
	#In the gram_schmidt lattice
	return s

e=_sage_const_10 **_sage_const_15 
size=_sage_const_3 *floor(float(log(e)))

print("nombre de vecteurs dans la base:", size)

M=MatrixSpace(ZZ,size)
#A=diagonal_matrix(ZZ, size, vector(ZZ, [ZZ.random_element(1, 1000) for i in 
#range(size)]))
A = random_matrix(ZZ, size, size, x=-_sage_const_300 , y=_sage_const_300 )
#A=M.random_element()


while A.rank() != size:
#ensures V has rank size
	A=M.random_element()
	print(A)



t=vector(ZZ, [e]+(size-_sage_const_1 )*[_sage_const_0 ])
#t=A.columns()[0]*10000

print("réduction d'un vecteur de taille:", float(log(e)))

A=A.BKZ(block_size=floor(sqrt(size)))
V=span(A.columns(), ZZ)

G,_=A.gram_schmidt()
#print(G)

t_2=babai(A,G,t)
print((log(max(t_2))), (t_2+t) in V)
print(t_2)
t_3=babai(A,G,t_2)
print(float(log(max(t_3))), (t_3+t_2) in V)
print(t_3)
t_4=babai(A,G,t_3)
print(float(log(max(t+t_4))), (t_4+t_3) in V)
print(t_4)

